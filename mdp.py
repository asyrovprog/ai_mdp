import sys
from random import *

class mdp_t(object):
    # start state (just one)
    def start_state(self):
        return self.get_state(0)

    # return array of possible actions
    def actions(self, s):
        pass

    # is this end state?
    def is_end(self, s):
        pass

    # return array of (probability, reward, next state) tuples
    def transitions(self, s, a):
        pass

    # sample transition (reward, next state) for specified state-action
    def transition(self, s, a):
        ta = self.transitions(s, a)
        p, r, t = 0.0, uniform(0, 1), None
        for i in range(len(ta)):
            t, p = ta[i], p + ta[i][0]
            if r <= p:
                break
        return t[1], t[2]

    def discount(self):
        return 1.0

    # size used only for policy iterator and value iterator algorithms where we need to enumerate
    # throw all states
    def size(self):
        return -1

    # get_state returns state for the specified state id (in range 0..size())
    def get_state(self, id):
        return id

# abstract policy (i.e. what action we select for each state of MDP)
class policy_t(object):
    def __init__(self, mdp):
        self.mdp = mdp

    # returns policy for passed state
    def action(self, s):
        pass

    # generate episode [state, action, reward, state, .... ], 3n+1 states (n >= 0)
    def create_episode(self, s):
        e, m = [s], self.mdp
        while not m.is_end(s):
            a = self.action(s)
            t = m.transition(s, a)
            e += [a, t[0], t[1]]
            s = t[1]
        return e


# random action policy
class random_policy_t(policy_t):
    def action(self, s):
        aa = self.mdp.actions(s)
        return aa[randint(0, len(aa) - 1)]


# policy based on provided to constructor dictionary {state: action}
class dict_policy_t(policy_t):
    def __init__(self, mdp, d):
        self.mdp = mdp
        self.d = d
    def action(self, s):
        return self.d[s]


# return total reward (utility) of episode array, generated by policy_t.create_episode
def episode_utility(m, e):
    r, d = 0, 1.0
    for i in range(1, len(e) - 1, 3):
        r += e[i + 1] * d
        d *= m.discount()
    return r
